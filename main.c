  /**********************************************************************************************
  *                                                                                             *
  *           ƒневные ходовые огни на Hyundai Sonata EF (дальний в четверть накала)             *
  *                                                                                             *
  *                                   ATtiny13A     0.6 MHz                                     *
  *                                                                                             *
  **********************************************************************************************/


  /**********************************************************************************************
  *                              ќЅЏя¬Ћ≈Ќ»≈ ѕ≈–≈ћ≈ЌЌџ’ » ‘”Ќ ÷»…                                *
  **********************************************************************************************/

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/eeprom.h>

#define LAMP                            0         // выход на лампы (PB0)
#define BTN                             1         // кнопка (PB1)
#define Control_1                       2         // управл€ющий пин (масло, фары) (PB2)
#define Control_2                       3         // управл€ющий пин (ручник) (PB3)
#define LED_indicator                   4         // индикатор кнопки и отключенных ƒ’ќ (PB4)
#define Light_Duty_Def                  52        // скважность по умолчанию                        (52 / 256 = 20%)
#define Time_Smooth                     2960      // врем€ плавного розжига (2500 ms * 1.18 = 2960) (1.18 = 4/3.4 поправочный коэф., чтобы уйти от дроби в расчете) (нужно число, при делении на 4 не образующее дробь в CountSmoothCalc())
#define Time_Delay_Before_Stop          1470      // задержка перед выключением                     (1470 * 3.4 ms = 5 sec)
#define Time_Ctrl_2_Countdown           882       // отведенное врем€ дл€ ручника                   (882 * 3.4 ms = 3 sec)
#define Times_for_Ctrl_2                3         // необходимое количество включений ручника за отведенное врем€
#define Count_max_btn                   118       // max значение счетчика (антидребезг кнопки)     (118 * 3.4 ms = 400 ms)
#define _smooth_is_need                 0         // флаг потребности плавного розжига (бит 0)
#define _DRL_started                    1         // флаг работающего ƒ’ќ (бит 1)
#define _btn_pressed                    2         // флаг нажатой кнопки (бит 2)
#define _delay_in_effect                3         // флаг действующей задержки выключени€ (бит 3)
#define _ctrl_2_countdown               4         // флаг отсчета времени дл€ Control_2 (бит 4)
#define _ctrl_2_switch                  5         // флаг сигнала (ручного тормоза) дл€ Control_2 (бит 5)
#define _DRL_off_by_ctrl_2              6         // флаг выключенных ручником ƒ’ќ
#define EE_byte_Set_1                   1         // номер €чейки EEPROM - настройки €чейка є1 (8 бит)
#define EE_byte_Set_2                   2         // номер €чейки EEPROM - настройки €чейка є2 (8 бит)
#define EE_byte_Init                    3         // номер €чейки EEPROM - €чейка инициализации (8 бит)

volatile uint8_t    Flag_Byte           = 0;      // флагова€ переменна€
volatile uint8_t    Count_Time          = 0;      // счетчик (инкрементируетс€ по переполнению таймера)
volatile uint16_t   Count_Delay_Stop    = 0;      // счетчик дл€ задержки (инкрементируетс€ по переполнению таймера)
volatile uint16_t   Count_Delay_Ctrl_2  = 0;      // счетчик дл€ отработки Control_2
volatile uint8_t    Count_Times_Ctrl_2  = 0;      // счетчик срабатываний ручника
volatile uint8_t    Delay_Smooth;                 // задержка дл€ плавного розжига
volatile uint8_t    Light_Duty;                   // скважность

void Presets(void);
void SmoothIgnition(void);
void StartDRL(void);
void StopDRL(void);
void LoadData(void);
void SaveData(void);
void ChangeBrightness(void);
void DelayBeforeStop(void);
void SettingsInit(void);
void CountSmoothCalc(void);


  /**********************************************************************************************
  *                                     ќ—Ќќ¬Ќјя ‘”Ќ ÷»я                                        *
  **********************************************************************************************/

int main (void)
{
  Presets();

  while (1)
  {
    if ((PINB & (1<<Control_1)) && (~Flag_Byte & (1<<_DRL_off_by_ctrl_2)))   // если на пине "1" и ƒ’ќ не выключены ручником - ¬ Ћё„≈Ќ»≈
    {
      if (~Flag_Byte & (1<<_DRL_started))                       // если ƒ’ќ вџключено
      {
        StartDRL();
      }
      else
      {
        if (Flag_Byte & (1<<_delay_in_effect))                  // если была активирована задержка на выключение
        {
          Flag_Byte &=~ (1<<_delay_in_effect);                  // отменить задержку
        }
      }
      
      if (Flag_Byte & (1<<_smooth_is_need))                     // если нужен плавный розжиг
      {
        SmoothIgnition();
      }
    }
    else                                                        // если на пине "0" - ¬џ Ћё„≈Ќ»≈
    {
      if (Flag_Byte & (1<<_DRL_started))
      {
        DelayBeforeStop();                                      // включение задержки с последующим выключением
      }
    }
  
    if ((Flag_Byte & (1<<_btn_pressed)) && (Count_Time >= Count_max_btn))    // нажата кнопка и отработан антидребезг
    {
      PORTB     &=  ~(1<<LED_indicator);                        // выкл. светодиод
      Flag_Byte &=  ~(1<<_btn_pressed);                         // сброс флага нажати€ кнопки
      ChangeBrightness();
      SaveData();
      GIMSK     |=  (1<<INT0);                                  // включение прерывани€ INT0
    }
    
    if ((Flag_Byte & (1<<_ctrl_2_switch)) && (Count_Time >= Count_max_btn))  // сигнал с ручника и отработан антидребезг
    {
      Flag_Byte &=  ~(1<<_ctrl_2_switch);                       // сброс флага сработавшего ручника
      Count_Times_Ctrl_2++;                                     // срабатывани€ ручника +1
      GIMSK     |=  (1<<PCIE);                                  // включение прерывани€ PCINT0
    }
  
    if ((Flag_Byte & (1<<_ctrl_2_countdown)) && (Count_Delay_Ctrl_2 >= Time_Ctrl_2_Countdown)) // если отсчет установленного времени окончен
    {
      if ((Count_Times_Ctrl_2 >= Times_for_Ctrl_2) && (PINB & (1<<Control_2)))  // если необходимое количество срабатываний достигнуто и отпущен ручник
      {
        if (~Flag_Byte & (1<<_DRL_off_by_ctrl_2))               // если ручником ƒ’ќ не выключены
        {
          Flag_Byte |=  (1<<_DRL_off_by_ctrl_2);                    
          PORTB     |=  (1<<LED_indicator);
          
          if (Flag_Byte & (1<<_DRL_started))                    // если ƒ’ќ включены
          {
            StopDRL();
          }
        } 
        else                                                    // если ручником ƒ’ќ выключены
        {
          Flag_Byte &= ~(1<<_DRL_off_by_ctrl_2);
          PORTB     &= ~(1<<LED_indicator);
        }
      }
      
      Count_Times_Ctrl_2 = 0;                                   // обнуление счетчика количества включени€ ручника
      Flag_Byte &=  ~(1<<_ctrl_2_countdown);                    // сбос флага отсчета дл€ отработки Control_2
    }
    
    asm("nop");
  }
}


  /**********************************************************************************************
  *                                    ќ—“јЋ№Ќџ≈ ‘”Ќ ÷»»                                        *
  **********************************************************************************************/

    /*---------------------------------- ѕредустановки --------------------------------------*/

void Presets (void)
{
  DDRB      |=  (1<<LAMP) | (1<<LED_indicator);                 // настройка портов
  DDRB      &=  ~((1<<BTN) | (1<<Control_1) | (1<<Control_2));
  PORTB     |=  (1<<BTN) | (1<<Control_1) | (1<<Control_2);
  Flag_Byte |=  (1<<_smooth_is_need);                           // включение плавного розжига
  
  MCUCR     |=  (1<<ISC01);                                     // прерывание INT0 по ниспадающему сигналу
  
  PCMSK     |=  (1<<PCINT3);                                    // прерывание по измененю уровн€ на пине –¬3
  GIMSK     |=  (1<<PCIE);                                      // включение прерывани€
  
  TCCR0A    |=  (1<<WGM00) | (1<<WGM01);                        // выбор режима работы таймера (табл. 11.8 стр. 73)        Fast PWM (3)
  TCCR0B    |=  (1<<CS01);                                      // установка предделител€ таймера (табл. 11.9 стр. 74)     8 (0.6 MHz/256/8=293 Hz (3.4 ms))
  OCR0A     =   1;                                              // начальное значение дл€ счетчика (11.9.4 стр. 75)       (скважность)
  TIMSK0    |=  (1<<TOIE0);                                     // включение прерываний по переполнению счетчика
  
  SettingsInit();
  LoadData();
  CountSmoothCalc();
  
  asm ("sei");                                                  // разрешение прерываний (стр. 161)
}

    /*----------------------------- »нициализаци€ настроек ---------------------------------*/

void SettingsInit (void)
{
  if (eeprom_read_byte((uint8_t*)EE_byte_Init) != 55)           // 55 - случайное число
  {
    eeprom_write_byte((uint8_t*)EE_byte_Set_1, Light_Duty_Def); // запись в €чейки предустановленного значени€
    eeprom_write_byte((uint8_t*)EE_byte_Set_2, Light_Duty_Def);
    Light_Duty = Light_Duty_Def;
    eeprom_write_byte((uint8_t*)EE_byte_Init, 55);              // запись в €чейку 55 - настройки восстановлены
  } 
}

    /*--------------------------------- ѕлавный розжиг -------------------------------------*/

void SmoothIgnition (void)
{
  if (Count_Time >= Delay_Smooth)                               // когда счетчик достиг нужного значени€
  {
    if (OCR0A < Light_Duty)                                     // если скважность еще не достигла своего уровн€
    {
      OCR0A++;                                                  // увеличение скважности
      Count_Time = 0;
    }
    else                                                        // если скважность достигла своего уровн€
    {
      Flag_Byte &= ~(1<<_smooth_is_need);                       // остановка плавного розжига
    }
  } 
}

    /*---------------------------------- ¬ключение ƒ’ќ --------------------------------------*/

void StartDRL(void)
{
  asm ("cli");
  Flag_Byte |=  (1<<_DRL_started);                              // установка флага включенного ƒ’ќ
  TCCR0A    |=  (1<<COM0A1);                                    // подключение пина OC0A (PB0) к выходу Ў»ћ-генератора
  GIMSK     |=  (1<<INT0);                                      // включение прерывани€ INT0
  asm ("sei");
} 

    /*---------------------------------- ¬ыключение ƒ’ќ -------------------------------------*/

void StopDRL(void)
{
  asm ("cli");
  Flag_Byte &=  ~(1<<_DRL_started);                             // сброс флага включенного ƒ’ќ
  TCCR0A    &=  ~(1<<COM0A1);                                   // отключение пина OC0A (PB0) от выхода Ў»ћ-генератора
  PORTB     &=  ~(1<<LAMP);                                     // выключение порта выхода на лампы
  OCR0A     =   1;                                              // начальное значение дл€ счетчика (дл€ плавного розжига)
  Flag_Byte |=  (1<<_smooth_is_need);                           // включение плавного розжига (дл€ последующего включени€)
  Flag_Byte &=  ~(1<<_delay_in_effect);                         // выключение задержки перед выключением
  GIMSK     &=  ~(1<<INT0);                                     // выключение прерывани€ INT0
  asm ("sei");
}

    /*---------------------------- «адержка перед выключением -------------------------------*/

void DelayBeforeStop(void)
{
  if (~Flag_Byte & (1<<_delay_in_effect))                       // если задержка еще не активирована
  {
    Flag_Byte |= (1<<_delay_in_effect);                         // включение задержки
    Count_Delay_Stop = 0;                                       // сброс счетчика задержки
  }
  
  if (Count_Delay_Stop >= Time_Delay_Before_Stop)               // если счетчик досчитал до установленного значени€
  {
    StopDRL();
  }
}

    /*--------------------------------- «агрузка данных -------------------------------------*/

void LoadData(void)
{
  if (eeprom_read_byte((uint8_t*)EE_byte_Set_1) == eeprom_read_byte((uint8_t*)EE_byte_Set_2)) // если значени€ в 2-х €чейках совпадают
  {
    Light_Duty = eeprom_read_byte((uint8_t*)EE_byte_Set_1);     // чтение из пам€ти сохраненного значени€ скважности
  }
  else                                                          // если произошел сбой и в €чейках разные данные
  {
    eeprom_write_byte((uint8_t*)EE_byte_Init, 0);               // сброс €чейки инициализации
    SettingsInit();                                             // сброс настроек
  }
}

    /*-------------------------------- —охранение данных ------------------------------------*/

void SaveData(void)
{
  eeprom_write_byte((uint8_t*)EE_byte_Set_1, Light_Duty);       // запись в €чейки нового значени€
  eeprom_write_byte((uint8_t*)EE_byte_Set_2, Light_Duty);
}

    /*-------------------------------- »зменение €ркости ------------------------------------*/

void ChangeBrightness(void)
{
  if (Light_Duty <= 97)                                         // предпоследнее значение из р€да значений скважности - 25, 34, 43, 52, 61, 70, 79, 88, 97, 106
  {
    Light_Duty += 9;                                            // от 25 до 106 с шагом 9 = 10 градаций €ркости (10%...41%)
  }
  else
  {
    Light_Duty = 25;                                            // первое значение из р€да значений скважности
  }
  
  OCR0A = Light_Duty;
  CountSmoothCalc();
}

    /*-------------------------- –асчет задержки плавного розжига ---------------------------*/

void CountSmoothCalc(void)
{
  Delay_Smooth = Time_Smooth / Light_Duty / 4;
}


  /**********************************************************************************************
  *                                         ѕ–≈–џ¬јЌ»я                                          *
  **********************************************************************************************/

    /*----------------------------- ѕо переполнению счетчика --------------------------------*/

ISR (TIM0_OVF_vect)                                             // каждые 3.4 мс
{
  Count_Time++;
  Count_Delay_Stop++;
  Count_Delay_Ctrl_2++;
}

    /*---------------------------- ѕо изменению состо€ни€ пинов -----------------------------*/

ISR (INT0_vect)                                                 // по спадающему сигналу INT0 
{
  if (~PINB & (1<<BTN))                                         // условие написано, т.к. прерывание срабатывало не только по спадающему сигналу (в ѕротеусе всЄ идеально работает и без услови€)
  {
    GIMSK       &=  ~(1<<INT0);                                 // запрет прерывани€ INT0
    Count_Time  =   0;                                          // сброс счетчика
    Flag_Byte   |=  (1<<_btn_pressed);                          // установка флага нажатой кнопки
    PORTB       |=  (1<<LED_indicator);                         // вкл. светодиод
  }
}

    /*---------------------------- ѕо изменению состо€ни€ пинов -----------------------------*/

ISR (PCINT0_vect)                                               // по изменению уровн€ PCINT0
{
  if (~PINB & (1<<Control_2))                                   // по низкому уровню PB3
  {
    GIMSK       &=  ~(1<<PCIE);                                 // запрет прерывани€ PCINT0
    Count_Time  =   0;                                          // сброс счетчика (дл€ антиюребезга)
    
    if (~Flag_Byte & (1<<_ctrl_2_countdown))                    // если отсчет еще не началс€ (первое срабатывание ручника)
    {
      Count_Delay_Ctrl_2 = 0;                                   // сброс счетчика времени ручника
      Flag_Byte   |=  (1<<_ctrl_2_countdown);                   // установка флага начала отсчета дл€ отработки Control_2
    }
    
    Flag_Byte   |=  (1<<_ctrl_2_switch);                        // установка флага поступлени€ сигнала Control_2
  }
}

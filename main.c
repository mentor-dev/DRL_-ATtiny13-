  /**********************************************************************************************
  *                                                                                             *
  *           Дневные ходовые огни на Hyundai Sonata EF (дальний в четверть накала)             *
  *                                                                                             *
  *                                   ATtiny13A     0.6 MHz                                     *
  *                                                                                             *
  **********************************************************************************************/


  /**********************************************************************************************
  *                              ОБЪЯВЛЕНИЕ ПЕРЕМЕННЫХ И ФУНКЦИЙ                                *
  **********************************************************************************************/

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/eeprom.h>

#define LAMP                            0         // выход на лампы (PB0)
#define BTN                             1         // кнопка (PB1)
#define Control_1                       2         // управляющий пин (масло, фары) (PB2)
#define Control_2                       3         // управляющий пин (ручник) (PB3)
#define LED_indicator                   4         // индикатор кнопки и отключенных ДХО (PB4)
#define Light_Duty_Def                  52        // скважность по умолчанию                        (52 / 256 = 20%)
#define Time_Smooth                     2960      // время плавного розжига (2500 ms * 1.18 = 2960) (1.18 = 4/3.4 поправочный коэф., чтобы уйти от дроби в расчете) (нужно число, при делении на 4 не образующее дробь в CountSmoothCalc())
#define Time_Delay_Before_Stop          1470      // задержка перед выключением                     (1470 * 3.4 ms = 5 sec)
#define Time_Ctrl_2_Countdown           882       // отведенное время для ручника                   (882 * 3.4 ms = 3 sec)
#define Times_for_Ctrl_2                3         // необходимое количество включений ручника за отведенное время
#define Count_max_btn                   118       // max значение счетчика (антидребезг кнопки)     (118 * 3.4 ms = 400 ms)
#define _smooth_is_need                 0         // флаг потребности плавного розжига (бит 0)
#define _DRL_started                    1         // флаг работающего ДХО (бит 1)
#define _btn_pressed                    2         // флаг нажатой кнопки (бит 2)
#define _delay_in_effect                3         // флаг действующей задержки выключения (бит 3)
#define _ctrl_2_countdown               4         // флаг отсчета времени для Control_2 (бит 4)
#define _ctrl_2_switch                  5         // флаг сигнала (ручного тормоза) для Control_2 (бит 5)
#define _DRL_off_by_ctrl_2              6         // флаг выключенных ручником ДХО
#define EE_byte_Set_1                   1         // номер ячейки EEPROM - настройки ячейка №1 (8 бит)
#define EE_byte_Set_2                   2         // номер ячейки EEPROM - настройки ячейка №2 (8 бит)
#define EE_byte_Init                    3         // номер ячейки EEPROM - ячейка инициализации (8 бит)

volatile uint8_t    Flag_Byte           = 0;      // флаговая переменная
volatile uint8_t    Count_Time          = 0;      // счетчик (инкрементируется по переполнению таймера)
volatile uint16_t   Count_Delay_Stop    = 0;      // счетчик для задержки (инкрементируется по переполнению таймера)
volatile uint16_t   Count_Delay_Ctrl_2  = 0;      // счетчик для отработки Control_2
volatile uint8_t    Count_Times_Ctrl_2  = 0;      // счетчик срабатываний ручника
volatile uint8_t    Delay_Smooth;                 // задержка для плавного розжига
volatile uint8_t    Light_Duty;                   // скважность

void Presets(void);
void SmoothIgnition(void);
void StartDRL(void);
void StopDRL(void);
void LoadData(void);
void SaveData(void);
void ChangeBrightness(void);
void DelayBeforeStop(void);
void SettingsInit(void);
void CountSmoothCalc(void);


  /**********************************************************************************************
  *                                     ОСНОВНАЯ ФУНКЦИЯ                                        *
  **********************************************************************************************/

int main (void)
{
  Presets();

  while (1)
  {
    if ((PINB & (1<<Control_1)) && (~Flag_Byte & (1<<_DRL_off_by_ctrl_2)))   // если на пине "1" и ДХО не выключены ручником - ВКЛЮЧЕНИЕ
    {
      if (~Flag_Byte & (1<<_DRL_started))                       // если ДХО вЫключено
      {
        StartDRL();
      }
      else
      {
        if (Flag_Byte & (1<<_delay_in_effect))                  // если была активирована задержка на выключение
        {
          Flag_Byte &=~ (1<<_delay_in_effect);                  // отменить задержку
        }
      }
      
      if (Flag_Byte & (1<<_smooth_is_need))                     // если нужен плавный розжиг
      {
        SmoothIgnition();
      }
    }
    else                                                        // если на пине "0" - ВЫКЛЮЧЕНИЕ
    {
      if (Flag_Byte & (1<<_DRL_started))
      {
        DelayBeforeStop();                                      // включение задержки с последующим выключением
      }
    }
  
    if ((Flag_Byte & (1<<_btn_pressed)) && (Count_Time >= Count_max_btn))    // нажата кнопка и отработан антидребезг
    {
      PORTB     &=  ~(1<<LED_indicator);                        // выкл. светодиод
      Flag_Byte &=  ~(1<<_btn_pressed);                         // сброс флага нажатия кнопки
      ChangeBrightness();
      SaveData();
      GIMSK     |=  (1<<INT0);                                  // включение прерывания INT0
    }
    
    if ((Flag_Byte & (1<<_ctrl_2_switch)) && (Count_Time >= Count_max_btn))  // сигнал с ручника и отработан антидребезг
    {
      Flag_Byte &=  ~(1<<_ctrl_2_switch);                       // сброс флага сработавшего ручника
      Count_Times_Ctrl_2++;                                     // срабатывания ручника +1
      GIMSK     |=  (1<<PCIE);                                  // включение прерывания PCINT0
    }
  
    if ((Flag_Byte & (1<<_ctrl_2_countdown)) && (Count_Delay_Ctrl_2 >= Time_Ctrl_2_Countdown)) // если отсчет установленного времени окончен
    {
      if ((Count_Times_Ctrl_2 >= Times_for_Ctrl_2) && (PINB & (1<<Control_2)))  // если необходимое количество срабатываний достигнуто и отпущен ручник
      {
        if (~Flag_Byte & (1<<_DRL_off_by_ctrl_2))               // если ручником ДХО не выключены
        {
          Flag_Byte |=  (1<<_DRL_off_by_ctrl_2);                    
          PORTB     |=  (1<<LED_indicator);
          
          if (Flag_Byte & (1<<_DRL_started))                    // если ДХО включены
          {
            StopDRL();
          }
        } 
        else                                                    // если ручником ДХО выключены
        {
          Flag_Byte &= ~(1<<_DRL_off_by_ctrl_2);
          PORTB     &= ~(1<<LED_indicator);
        }
      }
      
      Count_Times_Ctrl_2 = 0;                                   // обнуление счетчика количества включения ручника
      Flag_Byte &=  ~(1<<_ctrl_2_countdown);                    // сбос флага отсчета для отработки Control_2
    }
    
    asm("nop");
  }
}


  /**********************************************************************************************
  *                                    ОСТАЛЬНЫЕ ФУНКЦИИ                                        *
  **********************************************************************************************/

    /*---------------------------------- Предустановки --------------------------------------*/

void Presets (void)
{
  DDRB      |=  (1<<LAMP) | (1<<LED_indicator);                 // настройка портов
  DDRB      &=  ~((1<<BTN) | (1<<Control_1) | (1<<Control_2));
  PORTB     |=  (1<<BTN) | (1<<Control_1) | (1<<Control_2);
  Flag_Byte |=  (1<<_smooth_is_need);                           // включение плавного розжига
  
  MCUCR     |=  (1<<ISC01);                                     // прерывание INT0 по ниспадающему сигналу
  
  PCMSK     |=  (1<<PCINT3);                                    // прерывание по измененю уровня на пине РВ3
  GIMSK     |=  (1<<PCIE);                                      // включение прерывания
  
  TCCR0A    |=  (1<<WGM00) | (1<<WGM01);                        // выбор режима работы таймера (табл. 11.8 стр. 73)        Fast PWM (3)
  TCCR0B    |=  (1<<CS01);                                      // установка предделителя таймера (табл. 11.9 стр. 74)     8 (0.6 MHz/256/8=293 Hz (3.4 ms))
  OCR0A     =   1;                                              // начальное значение для счетчика (11.9.4 стр. 75)       (скважность)
  TIMSK0    |=  (1<<TOIE0);                                     // включение прерываний по переполнению счетчика
  
  SettingsInit();
  LoadData();
  CountSmoothCalc();
  
  asm ("sei");                                                  // разрешение прерываний (стр. 161)
}

    /*----------------------------- Инициализация настроек ---------------------------------*/

void SettingsInit (void)
{
  if (eeprom_read_byte((uint8_t*)EE_byte_Init) != 55)           // 55 - случайное число
  {
    eeprom_write_byte((uint8_t*)EE_byte_Set_1, Light_Duty_Def); // запись в ячейки предустановленного значения
    eeprom_write_byte((uint8_t*)EE_byte_Set_2, Light_Duty_Def);
    Light_Duty = Light_Duty_Def;
    eeprom_write_byte((uint8_t*)EE_byte_Init, 55);              // запись в ячейку 55 - настройки восстановлены
  } 
}

    /*--------------------------------- Плавный розжиг -------------------------------------*/

void SmoothIgnition (void)
{
  if (Count_Time >= Delay_Smooth)                               // когда счетчик достиг нужного значения
  {
    if (OCR0A < Light_Duty)                                     // если скважность еще не достигла своего уровня
    {
      OCR0A++;                                                  // увеличение скважности
      Count_Time = 0;
    }
    else                                                        // если скважность достигла своего уровня
    {
      Flag_Byte &= ~(1<<_smooth_is_need);                       // остановка плавного розжига
    }
  } 
}

    /*---------------------------------- Включение ДХО --------------------------------------*/

void StartDRL(void)
{
  asm ("cli");
  Flag_Byte |=  (1<<_DRL_started);                              // установка флага включенного ДХО
  TCCR0A    |=  (1<<COM0A1);                                    // подключение пина OC0A (PB0) к выходу ШИМ-генератора
  GIMSK     |=  (1<<INT0);                                      // включение прерывания INT0
  asm ("sei");
} 

    /*---------------------------------- Выключение ДХО -------------------------------------*/

void StopDRL(void)
{
  asm ("cli");
  Flag_Byte &=  ~(1<<_DRL_started);                             // сброс флага включенного ДХО
  TCCR0A    &=  ~(1<<COM0A1);                                   // отключение пина OC0A (PB0) от выхода ШИМ-генератора
  PORTB     &=  ~(1<<LAMP);                                     // выключение порта выхода на лампы
  OCR0A     =   1;                                              // начальное значение для счетчика (для плавного розжига)
  Flag_Byte |=  (1<<_smooth_is_need);                           // включение плавного розжига (для последующего включения)
  Flag_Byte &=  ~(1<<_delay_in_effect);                         // выключение задержки перед выключением
  GIMSK     &=  ~(1<<INT0);                                     // выключение прерывания INT0
  asm ("sei");
}

    /*---------------------------- Задержка перед выключением -------------------------------*/

void DelayBeforeStop(void)
{
  if (~Flag_Byte & (1<<_delay_in_effect))                       // если задержка еще не активирована
  {
    Flag_Byte |= (1<<_delay_in_effect);                         // включение задержки
    Count_Delay_Stop = 0;                                       // сброс счетчика задержки
  }
  
  if (Count_Delay_Stop >= Time_Delay_Before_Stop)               // если счетчик досчитал до установленного значения
  {
    StopDRL();
  }
}

    /*--------------------------------- Загрузка данных -------------------------------------*/

void LoadData(void)
{
  if (eeprom_read_byte((uint8_t*)EE_byte_Set_1) == eeprom_read_byte((uint8_t*)EE_byte_Set_2)) // если значения в 2-х ячейках совпадают
  {
    Light_Duty = eeprom_read_byte((uint8_t*)EE_byte_Set_1);     // чтение из памяти сохраненного значения скважности
  }
  else                                                          // если произошел сбой и в ячейках разные данные
  {
    eeprom_write_byte((uint8_t*)EE_byte_Init, 0);               // сброс ячейки инициализации
    SettingsInit();                                             // сброс настроек
  }
}

    /*-------------------------------- Сохранение данных ------------------------------------*/

void SaveData(void)
{
  eeprom_write_byte((uint8_t*)EE_byte_Set_1, Light_Duty);       // запись в ячейки нового значения
  eeprom_write_byte((uint8_t*)EE_byte_Set_2, Light_Duty);
}

    /*-------------------------------- Изменение яркости ------------------------------------*/

void ChangeBrightness(void)
{
  if (Light_Duty <= 97)                                         // предпоследнее значение из ряда значений скважности - 25, 34, 43, 52, 61, 70, 79, 88, 97, 106
  {
    Light_Duty += 9;                                            // от 25 до 106 с шагом 9 = 10 градаций яркости (10%...41%)
  }
  else
  {
    Light_Duty = 25;                                            // первое значение из ряда значений скважности
  }
  
  OCR0A = Light_Duty;
  CountSmoothCalc();
}

    /*-------------------------- Расчет задержки плавного розжига ---------------------------*/

void CountSmoothCalc(void)
{
  Delay_Smooth = Time_Smooth / Light_Duty / 4;
}


  /**********************************************************************************************
  *                                         ПРЕРЫВАНИЯ                                          *
  **********************************************************************************************/

    /*----------------------------- По переполнению счетчика --------------------------------*/

ISR (TIM0_OVF_vect)                                             // каждые 3.4 мс
{
  Count_Time++;
  Count_Delay_Stop++;
  Count_Delay_Ctrl_2++;
}

    /*---------------------------- По изменению состояния пинов -----------------------------*/

ISR (INT0_vect)                                                 // по спадающему сигналу INT0 
{
  if (~PINB & (1<<BTN))                                         // условие написано, т.к. прерывание срабатывало не только по спадающему сигналу (в Протеусе всё идеально работает и без условия)
  {
    GIMSK       &=  ~(1<<INT0);                                 // запрет прерывания INT0
    Count_Time  =   0;                                          // сброс счетчика
    Flag_Byte   |=  (1<<_btn_pressed);                          // установка флага нажатой кнопки
    PORTB       |=  (1<<LED_indicator);                         // вкл. светодиод
  }
}

    /*---------------------------- По изменению состояния пинов -----------------------------*/

ISR (PCINT0_vect)                                               // по изменению уровня PCINT0
{
  if (~PINB & (1<<Control_2))                                   // по низкому уровню PB3
  {
    GIMSK       &=  ~(1<<PCIE);                                 // запрет прерывания PCINT0
    Count_Time  =   0;                                          // сброс счетчика (для антиюребезга)
    
    if (~Flag_Byte & (1<<_ctrl_2_countdown))                    // если отсчет еще не начался (первое срабатывание ручника)
    {
      Count_Delay_Ctrl_2 = 0;                                   // сброс счетчика времени ручника
      Flag_Byte   |=  (1<<_ctrl_2_countdown);                   // установка флага начала отсчета для отработки Control_2
    }
    
    Flag_Byte   |=  (1<<_ctrl_2_switch);                        // установка флага поступления сигнала Control_2
  }
}
